"""Vulnerability scanner module for XSS and SQLi detection."""
import re
from typing import List, Dict, Any, Optional
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class RiskLevel(Enum):
    """Risk level enumeration."""
    SAFE = "safe"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"


class VulnerabilityScanner:
    """Scans input for XSS and SQL injection vulnerabilities."""
    
    def __init__(self, rules: Optional[List[Dict[str, Any]]] = None):
        """Initialize vulnerability scanner.
        
        Args:
            rules: Custom scanning rules (optional)
        """
        self.xss_patterns = self._load_xss_patterns()
        self.sqli_patterns = self._load_sqli_patterns()
        
        if rules:
            self._load_custom_rules(rules)
    
    def _load_xss_patterns(self) -> List[Dict[str, str]]:
        """Load default XSS detection patterns.
        
        Returns:
            List of pattern dictionaries
        """
        return [
            {
                'pattern': r'<script[^>]*>.*?</script>',
                'description': 'Script tag detection',
                'severity': 'high'
            },
            {
                'pattern': r'javascript:',
                'description': 'JavaScript protocol in URL or attribute',
                'severity': 'high'
            },
            {
                'pattern': r'on\w+\s*=',
                'description': 'Event handler attribute (onclick, onerror, etc.)',
                'severity': 'high'
            },
            {
                'pattern': r'<iframe[^>]*>',
                'description': 'Iframe tag detection',
                'severity': 'medium'
            },
            {
                'pattern': r'<img[^>]*src\s*=\s*["\']?javascript:',
                'description': 'Image with JavaScript source',
                'severity': 'high'
            },
            {
                'pattern': r'<svg[^>]*>.*?<script',
                'description': 'SVG with embedded script',
                'severity': 'high'
            },
            {
                'pattern': r'<body[^>]*onload',
                'description': 'Body tag with onload event',
                'severity': 'medium'
            },
            {
                'pattern': r'<input[^>]*onfocus',
                'description': 'Input tag with onfocus event',
                'severity': 'medium'
            },
            {
                'pattern': r'<link[^>]*href\s*=\s*["\']?javascript:',
                'description': 'Link tag with JavaScript href',
                'severity': 'high'
            },
            {
                'pattern': r'eval\s*\(',
                'description': 'JavaScript eval() function',
                'severity': 'high'
            },
            {
                'pattern': r'<object[^>]*data\s*=\s*["\']?javascript:',
                'description': 'Object tag with JavaScript data',
                'severity': 'high'
            },
            {
                'pattern': r'<embed[^>]*src\s*=\s*["\']?javascript:',
                'description': 'Embed tag with JavaScript source',
                'severity': 'high'
            },
        ]
    
    def _load_sqli_patterns(self) -> List[Dict[str, str]]:
        """Load default SQL injection detection patterns.
        
        Returns:
            List of pattern dictionaries
        """
        return [
            {
                'pattern': r'(\bUNION\b.*\bSELECT\b)',
                'description': 'UNION SELECT injection attempt',
                'severity': 'high'
            },
            {
                'pattern': r'(\bOR\b|\bAND\b)\s*[\'"]?\s*\d+\s*=\s*\d+',
                'description': 'Boolean-based SQL injection (numeric)',
                'severity': 'high'
            },
            {
                'pattern': r'(\bOR\b|\bAND\b)\s*[\'"]?\s*[\'"][\'"]?\s*=\s*[\'"][\'"]?',
                'description': 'Boolean-based SQL injection (string)',
                'severity': 'high'
            },
            {
                'pattern': r';\s*(DROP|DELETE|UPDATE|INSERT|ALTER|CREATE|EXEC|EXECUTE)',
                'description': 'SQL command injection attempt',
                'severity': 'high'
            },
            {
                'pattern': r'(\'|\"|;|--|\#|\/\*|\*\/)',
                'description': 'SQL special characters and comment delimiters',
                'severity': 'medium'
            },
            {
                'pattern': r'\b(EXEC|EXECUTE|xp_|sp_)\b',
                'description': 'SQL procedure/function call',
                'severity': 'high'
            },
            {
                'pattern': r'\bSELECT\b.*\bFROM\b',
                'description': 'SELECT FROM statement',
                'severity': 'medium'
            },
            {
                'pattern': r'\bINSERT\s+INTO\b',
                'description': 'INSERT INTO statement',
                'severity': 'high'
            },
            {
                'pattern': r'\bDROP\s+(TABLE|DATABASE|INDEX)\b',
                'description': 'DROP statement',
                'severity': 'high'
            },
            {
                'pattern': r'\bUPDATE\b.*\bSET\b',
                'description': 'UPDATE SET statement',
                'severity': 'high'
            },
            {
                'pattern': r'\bDELETE\s+FROM\b',
                'description': 'DELETE FROM statement',
                'severity': 'high'
            },
            {
                'pattern': r'(\'\s*OR\s*\'\d+\'\s*=\s*\'\d+)|(".*OR.*".*=\s*".*)',
                'description': 'String-based boolean SQL injection',
                'severity': 'high'
            },
            {
                'pattern': r'\/\*.*?\*\/',
                'description': 'SQL comment block',
                'severity': 'medium'
            },
            {
                'pattern': r'--\s',
                'description': 'SQL line comment',
                'severity': 'medium'
            },
            {
                'pattern': r'\bCONCAT\s*\(',
                'description': 'SQL CONCAT function',
                'severity': 'medium'
            },
        ]
    
    def _load_custom_rules(self, rules: List[Dict[str, Any]]) -> None:
        """Load custom scanning rules.
        
        Args:
            rules: List of rule dictionaries
        """
        for rule in rules:
            if not rule.get('enabled', True):
                continue
            
            rule_dict = {
                'pattern': rule['pattern'],
                'description': rule.get('description', 'Custom rule'),
                'severity': rule.get('severity', 'medium')
            }
            
            if rule['rule_type'] == 'xss':
                self.xss_patterns.append(rule_dict)
            elif rule['rule_type'] == 'sqli':
                self.sqli_patterns.append(rule_dict)
    
    def scan(self, input_data: str) -> Dict[str, Any]:
        """Scan input data for vulnerabilities.
        
        Args:
            input_data: Input string to scan
            
        Returns:
            Dictionary with scan results
        """
        if not input_data:
            return {
                'xss_detected': False,
                'sqli_detected': False,
                'risk_level': RiskLevel.SAFE.value,
                'xss_findings': [],
                'sqli_findings': [],
                'summary': 'No input provided'
            }
        
        # Scan for XSS
        xss_results = self._scan_xss(input_data)
        
        # Scan for SQLi
        sqli_results = self._scan_sqli(input_data)
        
        # Determine risk level
        risk_level = self._calculate_risk_level(xss_results, sqli_results)
        
        # Generate summary
        summary = self._generate_summary(xss_results, sqli_results, risk_level)
        
        return {
            'xss_detected': len(xss_results) > 0,
            'sqli_detected': len(sqli_results) > 0,
            'risk_level': risk_level.value,
            'xss_findings': xss_results,
            'sqli_findings': sqli_results,
            'summary': summary
        }
    
    def _scan_xss(self, input_data: str) -> List[Dict[str, Any]]:
        """Scan for XSS vulnerabilities.
        
        Args:
            input_data: Input string to scan
            
        Returns:
            List of XSS findings
        """
        findings = []
        
        for pattern_info in self.xss_patterns:
            pattern = pattern_info['pattern']
            matches = re.finditer(pattern, input_data, re.IGNORECASE | re.DOTALL)
            
            for match in matches:
                findings.append({
                    'type': 'XSS',
                    'severity': pattern_info['severity'],
                    'description': pattern_info['description'],
                    'matched_text': match.group(0)[:100],  # Limit length
                    'position': match.start()
                })
        
        return findings
    
    def _scan_sqli(self, input_data: str) -> List[Dict[str, Any]]:
        """Scan for SQL injection vulnerabilities.
        
        Args:
            input_data: Input string to scan
            
        Returns:
            List of SQLi findings
        """
        findings = []
        
        for pattern_info in self.sqli_patterns:
            pattern = pattern_info['pattern']
            matches = re.finditer(pattern, input_data, re.IGNORECASE)
            
            for match in matches:
                findings.append({
                    'type': 'SQLi',
                    'severity': pattern_info['severity'],
                    'description': pattern_info['description'],
                    'matched_text': match.group(0)[:100],  # Limit length
                    'position': match.start()
                })
        
        return findings
    
    def _calculate_risk_level(
        self,
        xss_findings: List[Dict[str, Any]],
        sqli_findings: List[Dict[str, Any]]
    ) -> RiskLevel:
        """Calculate overall risk level.
        
        Args:
            xss_findings: List of XSS findings
            sqli_findings: List of SQLi findings
            
        Returns:
            Risk level enum
        """
        if not xss_findings and not sqli_findings:
            return RiskLevel.SAFE
        
        high_severity_count = sum(
            1 for f in xss_findings + sqli_findings
            if f['severity'] == 'high'
        )
        
        medium_severity_count = sum(
            1 for f in xss_findings + sqli_findings
            if f['severity'] == 'medium'
        )
        
        total_findings = len(xss_findings) + len(sqli_findings)
        
        if high_severity_count >= 2 or total_findings >= 5:
            return RiskLevel.HIGH
        elif high_severity_count >= 1 or medium_severity_count >= 3:
            return RiskLevel.MEDIUM
        else:
            return RiskLevel.LOW
    
    def _generate_summary(
        self,
        xss_findings: List[Dict[str, Any]],
        sqli_findings: List[Dict[str, Any]],
        risk_level: RiskLevel
    ) -> str:
        """Generate summary message.
        
        Args:
            xss_findings: List of XSS findings
            sqli_findings: List of SQLi findings
            risk_level: Calculated risk level
            
        Returns:
            Summary message
        """
        if risk_level == RiskLevel.SAFE:
            return "No vulnerabilities detected. The input appears to be safe."
        
        parts = []
        
        if xss_findings:
            parts.append(f"{len(xss_findings)} XSS vulnerability(s) detected")
        
        if sqli_findings:
            parts.append(f"{len(sqli_findings)} SQL injection vulnerability(s) detected")
        
        summary = f"Risk level: {risk_level.value.upper()}. " + "; ".join(parts) + "."
        
        if risk_level == RiskLevel.HIGH:
            summary += " This input is highly suspicious and should not be processed."
        elif risk_level == RiskLevel.MEDIUM:
            summary += " This input should be carefully reviewed before processing."
        else:
            summary += " This input should be validated and sanitized before use."
        
        return summary

